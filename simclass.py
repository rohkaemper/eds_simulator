""" Simulation object """
import utils
import logging
# import pprint
# import decimal
# import random


class Sim_source(object):
    """ Simulation Queue object serves as source for generating processes.

        parameters:
        - config holds the overall configuration information from '''sim.cfg'''
        - env (simpy '''Environment''' the object is in)
        - res (simpy '''Resource''' queue)
        - '''seed''' for random number generator of this run
        - '''capacity''' of '''res''' (queue)

        generators for interarrival_rate, service_time and patience are read from '''generator.csv'''
        variables for plot_log, drop_log, and time_in_system
    """

    def __init__(self, env, res, config, adv_config, repetition):
        self.env = env
        self.res = res
        self.interarrival_rate = int(config['avg_interarrival_time'])+(repetition * int(adv_config['alter_interarrival_time_by']))
        self.service_duration = int(config['service_time'])
        self.avg_patience = config['avg_patience']
        self.generators = utils.read_generators('./opt/generator.csv')
        self.interarrival_generator = self.generators[
            int(config['interarrival_gen'])]
        self.service_time_generator = self.generators[
            int(config['service_time_gen'])]
        self.patience_generator = self.generators[int(config['patience_gen'])]
        self.generated_processes = 0
        self.log = []
        self.plot_log = []
        self.drop_log = []
        self.time_in_system_log = []
        logging.debug('Source object initialized')

        # This generates a process of instantiated object
        env.process(self.run())

    def run(self):
        """ The source is responsible to generate processeses as long as the simulation is active.
        """

        while(True):
            # generate time for next process and it's service time
            next_event = self.interarrival_generator(self.interarrival_rate)
            process_service_time = self.service_time_generator(
                self.service_duration)
            process_patience = .0
            # check for patience configuration ('''max''' = infinity, '''value''' or '''0''' for drop_queue)
            if (self.avg_patience.isdigit() and (float(self.avg_patience) > .0)):
                process_patience = self.patience_generator(float(self.avg_patience))
            elif (self.avg_patience == 'max'):
                # processes have always maxvalue
                process_patience = float('inf')
            else:
                process_patience = 0
            process_patience = max(process_patience, 0)
            assert process_patience >= 0, 'Value must be positive!'
            yield self.env.timeout(next_event)
            # generate new process
            self.generated_processes += 1
            config = self.env, self.res, process_service_time, process_patience
            NewProcess = Process(config, self.log, self.plot_log, self.drop_log, self.generated_processes, self.time_in_system_log)
            # start the process
            self.env.process(NewProcess.run())


class Process(object):
    """ Process object, that is generated by '''Source'''

        The process is initialized with various parameters:
        - config (object that holds the overall configuration of simulation)
        - log, plot_log, drop_log, time_in_system_log -> log variables
        - process number

        The process holds information of
        - time it '''entered the system'''
        - time units (tu) it had to '''wait'''
        - if it got '''dropped_out'''
    """
    def __init__(self, config, log, plot_log, drop_log, process_number, time_in_system_log):
        env, res, service_time, process_patience = config
        self.env = env
        self.res = res
        self.entered_system = self.env.now
        self.wait = .0
        self.service_time = service_time
        self.process_patience = process_patience
        self.dropped_out = False
        self.time_in_system = .0
        self.process_number = process_number
        self.log = log
        self.plot_log = plot_log
        self.drop_log = drop_log
        self.time_in_system_log = time_in_system_log
        logging.debug('Process object generated.')

    def run(self):
        """ Process active actions.

            Enter Queue --> drop out
                |               |
                v               v
            get served  --> leave system

            1. Process tries to enter queue.
                ??? Is it a drop queue -> patience != 0 ???
            2. IF process gets served; log queue count and time in system
            3. ELSE process gets dropped after waiting (>= 0 tu); log queue count, time of drop event and time in system
        """
        self.res_usage_in = int(self.res.count)
        self.log_queue_count()
        # try to enter queue
        with self.res.request() as req:
            # drop event OR get served
            result = yield req | self.env.timeout(self.process_patience)

            self.wait = self.env.now - self.entered_system
            # evaluate if we get served OR if we drop out
            if req not in result:
                self.drop_out()
            else:
                yield self.env.timeout(self.service_time)
                self.time_in_system = self.env.now - self.entered_system
                self.time_in_system_log.append(self.time_in_system)
                self.log_queue_count()
                logging.debug(
                    'Process has been served [entered: %.2f -- left: %.2f].' % (self.entered_system, self.env.now))
        # process lifecycle ends, finish up information collection.
        self.res_usage_out = int(self.res.count)
        self.log.append([self.process_number, self.entered_system, self.wait, self.service_time,
                         self.time_in_system, self.dropped_out, self.res_usage_in, self.res_usage_out])

    def drop_out(self):
        """ Log event

            If drop occurs log queue count at time of drop, log time in system and set '''dropped_out''' to true.
        """
        self.log_queue_count()
        self.time_in_system = (self.env.now - self.entered_system)
        self.time_in_system_log.append(self.time_in_system)
        self.dropped_out = True
        self.drop_log.append(self.env.now)
        logging.debug('Process dropped out at %.2f.' % self.env.now)

    def log_queue_count(self):
        """ Returns list with '''timestamp''' and '''queue count''' """
        self.plot_log.append([self.env.now, self.res.count])
